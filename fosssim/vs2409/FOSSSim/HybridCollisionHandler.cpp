#include "HybridCollisionHandler.h"
#include "ContinuousTimeUtilities.h"
#include <iostream>
#include <set>
#include <algorithm>
#include "HybridCollisionComparison.h"

HybridCollisionHandler::HybridCollisionHandler(int maxiters, double COR) : ContinuousTimeCollisionHandler(COR), m_maxiters(maxiters)
{

}

HybridCollisionHandler::~HybridCollisionHandler()
{

}

void syncScene();

// Applies hybrid collision response to the simulation.
// For up to m_maxiters iterations:
//  - Find all pairs of colliding primitives using continuous-time collision detection
//  - Simultaneously apply an impulse for each detected collision
// After m_maxiters iterations, resolves remaining collisions using the failsafe, as described in the assignment instructions
//
// Does not need to be modified by students
void HybridCollisionHandler::handleCollisions(TwoDScene &scene, const VectorXs &oldpos, VectorXs &oldvel, scalar dt)
{    
    VectorXs xend(oldpos.size());
    VectorXs vend(oldvel.size());
    
    xend = scene.getX();
    vend = scene.getV();
    
    bool done = applyIterativeImpulses(scene, oldpos, scene.getX(), scene.getV(), dt, xend, vend);
    
    scene.getX() = xend;
    scene.getV() = vend;
    
    syncScene();
    
    if(!done)
        applyGeometricCollisionHandling(scene, oldpos, xend, vend, dt, scene.getX(), scene.getV());
}

// Takes start of time step and end of time step positions, and performs continuous-time collision detection.
// Inputs:
//   scene:   The simulation scene, needed for radii, etc.
//   qs:      Start of time step positions.
//   qe:      End of time step positions.
// Output:
//   Returns a list of all collisions found after performing continuous-time collision detection using positions qs and qe.
std::vector<CollisionInfo> HybridCollisionHandler::detectCollisions(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe)
{
    Vector2s n;
    double time;
    std::vector<CollisionInfo> result;
    for (int i = 0; i < scene.getNumParticles(); i++)
    {
        for (int j = i + 1; j < scene.getNumParticles(); j++)
        {
            if (detectParticleParticle(scene, qs, qe, i, j, n, time))
            {
                result.push_back(CollisionInfo(CollisionInfo::PP, i, j, n, time));
            }
        }
        
        for (int e = 0; e < scene.getNumEdges(); e++)
        {
            if (scene.getEdges()[e].first != i && scene.getEdges()[e].second != i)
                if (detectParticleEdge(scene, qs, qe, i, e, n, time))
                {
                    result.push_back(CollisionInfo(CollisionInfo::PE, i, e, n, time));
                }
        }

        for (int f = 0; f < scene.getNumHalfplanes(); f++)
        {
            if (detectParticleHalfplane(scene, qs, qe, i, f, n, time))
            {
                result.push_back(CollisionInfo(CollisionInfo::PH, i, f, n, time));
            }
        }
    }
    return result;
}

// Takes a list of detected collisions, positions at the start of time step, and predicted end of time step positions and velocities, and updates the
// predicted quantities by applying impulses.
// Inputs:
//   scene:      The simulation scene, needed for radii, masses, etc.
//   collisions: The list, generated by detectCollisions, of collisions that need to be responded to.
//   qs:         Start of time step positions.
//   qe:         Predicted end of time step positions.
//   qdote:      Predicted enf of time step velocities.
//   dt          The time step length
// Outputs:
//   qm:         Predicted end of time step positions after impulses have been applied. Do *NOT* pass in the same vector as for qe!
//   qdotm:      Predicted end of time step velocities after impulses have been applied.
void HybridCollisionHandler::applyImpulses(const TwoDScene &scene, const std::vector<CollisionInfo> &collisions, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qm, VectorXs &qdotm)
{
    qm = qe;
    qdotm = qdote;
    for (int i = 0; i < (int)collisions.size(); i++)
    {
        switch (collisions[i].m_type)
        {
            case CollisionInfo::PP:
            {
                respondParticleParticle(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
            case CollisionInfo::PE:
            {
                respondParticleEdge(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
            case CollisionInfo::PH:
            {
                respondParticleHalfplane(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
        }
    }
}



std::string HybridCollisionHandler::getName() const
{
    return "Hybrid Collision Handling";
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        Impact Zone Utilities
////
////        You can use them, or implement your own versions of whatever you need
////
////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

bool intersects(const ImpactZone &z1, const ImpactZone &z2)
{
    std::set<int> temp;
    set_intersection(z1.m_verts.begin(), z1.m_verts.end(), z2.m_verts.begin(), z2.m_verts.end(), inserter(temp, temp.end()));
    return temp.size() > 0;
}

ImpactZone mergeZones(const ImpactZone &z1, const ImpactZone &z2)
{
    std::set<int> combinedverts;
    set_union(z1.m_verts.begin(), z1.m_verts.end(), z2.m_verts.begin(), z2.m_verts.end(), inserter(combinedverts, combinedverts.end()));
    return ImpactZone(combinedverts, z1.m_halfplane || z2.m_halfplane);
}


void mergeAllZones(ImpactZones &zones)
{
    ImpactZones result;
    
    ImpactZones *src = &zones;
    ImpactZones *dst = &result;
    do
    {
        dst->clear();
        for(int i=0; i<(int)src->size(); i++)
        {
            bool merged = false;
            for(int j=0; j<(int)dst->size(); j++)
            {
                if(intersects((*dst)[j], (*src)[i]))
                {
                    ImpactZone newzone = mergeZones((*dst)[j], (*src)[i]);
                    (*dst)[j] = newzone;
                    merged = true;
                    
                    break;
                }
            }
            if(!merged)
            {
                dst->push_back((*src)[i]);
            }
        }
        std::swap(src, dst);
    }
    while(src->size() < dst->size());
    
    zones = *dst;
}

void growImpactZones(const TwoDScene &scene, ImpactZones &zones, const std::vector<CollisionInfo> &impulses)
{
    for(int i=0; i<(int)impulses.size(); i++)
    {
        switch(impulses[i].m_type)
        {
            case CollisionInfo::PP:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                verts.insert(impulses[i].m_idx2);
                zones.push_back(ImpactZone(verts, false));
                break;
            }
            case CollisionInfo::PE:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                verts.insert(scene.getEdge(impulses[i].m_idx2).first);
                verts.insert(scene.getEdge(impulses[i].m_idx2).second);
                zones.push_back(ImpactZone(verts, false));
                break;
            }
            case CollisionInfo::PH:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                zones.push_back(ImpactZone(verts, true));
                break;
            }
        }
    }
    mergeAllZones(zones);
}

bool zonesEqual(const ImpactZones &zones1, const ImpactZones &zones2)
{
    if(zones1.size() != zones2.size())
        return false;
    
    for(int i=0; i<(int)zones1.size(); i++)
    {
        bool found = false;
        for(int j=0; j<(int)zones2.size(); j++)
        {
            if(zones1[i] == zones2[j])
            {
                found = true;
                
                break;
            }
        }
        if(!found)
            return false;
    }
    return true;
}





////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        Student Code
////
////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////



// Iteratively performs collision detection and interative impulse response until either there are no more detected collisions, or the maximum number of
// iterations has been reached. See the assignment instructions for more details.
// The maximum number of iterations is stored in the member variable m_maxiters.
// Inputs:
//   scene:   The simulation scene. Get masses, radii, edge endpoint indices, etc. from here. Do *NOT* get any positions or velocities from here.
//   qs:      The positions of the particles at the start of the time step.
//   qe:      The predicted end-of-time-step positions.
//   qdote:   The predicted end-of-time-step velocities.
//   dt:      The time step size.
// Outputs:
//   qefinal:    The collision-free end-of-time-step positions (if no new collisions are detected), or the last set of predicted end-of-time-step positions
//               (if maximum number of iterations reached).
//   qdotefinal: Same as qefinal, but for velocities.
//   Returns true if the algorithm found a collision-free state. Returns false if the maximum number of iterations was reached without finding a collision-
//   free state.
// Possibly useful functions: detectCollisions, applyImpulses.
bool HybridCollisionHandler::applyIterativeImpulses(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qefinal, VectorXs &qdotefinal)
{	
//    // Your implementation here
//
//	return false;
	qefinal = qe;
	qdotefinal = qdote;
	for (int i = 0; i < m_maxiters; i++)
	{
		std::vector<CollisionInfo> collisions = detectCollisions(scene, qs, qefinal);
		if (collisions.size() == 0)
		{
			//std::cout << "collision resolved after " << i << " iterations of impulses." << std::endl;
			return true;
		} else 
		{
			VectorXs newqe = qefinal;
			VectorXs newqdote = qdotefinal;
			applyImpulses(scene, collisions, qs, newqe, newqdote, dt, qefinal, qdotefinal);
		}
	}
	
	//std::cout << "maxiters reached; impulse failed." << std::endl;
	return false;
}


// Resolves any remaining collisions in a simulation time step by setting the velocities of all particles involved in a way that guarantees
// that the distance between particles in an impact zone does not change.
// Inputs:
//   scene:   The simulation scene, from which the masses of the particles, current (colliding) positions, and whether or not a given particle is fixed,
//             can be retrieved.
//   qs:      The positions of the particles at the start of the time step.
//   qe:      The predicted end-of-timestep positions of the particles.
//   qdote:   The precicted end-of-timestep velocities of the particles.
//   zone:    Information about the impact zone of colliding particles. zone.m_verts is an std::set of particle indices; each particle in this set
//            is part of the impact zone and needs to have its position and velocity changed. Whether or not a half-plane is part of the impact zone
//            can be checked by looking at zone.m_halfplane.
//   dt:      The time step.
// Outputs:
//   qe:      The end-of-timestep position of the particles, assuming rigid motion as in writeup section 4.5
//   qdote:   The end-of-timestep velocity of the particles, assuming rigid motion as in writeup section 4.5
void HybridCollisionHandler::performFailsafe(const TwoDScene &scene, const VectorXs &qs, const ImpactZone &zone, double dt, VectorXs &qe, VectorXs &qdote)
{
//    //
//    // What you need to implement here: (same as writeup section 4.5)
//    //
//    // 1. Treat the particles as if they were part of a rigid body; that is, treat them as if 
//    //      we connected them with rigid beams at the start of the time step.
//    // 2. Step the rigid body forward in time to the end of the time step.
//    // 3. Set each particle’s modified end-of-time-step position qm to the position dictated 
//    //      by the motion of the rigid body.
//    // 4. Also set the particle’s modified end-of-time-step velocity to (qm − qs) / h, where 
//    //      h is the length of the time step.
//    //
//    
//    // Don't forget to handle fixed objects properly as in writeup section 4.5.1    
//    
//    // Your implementation here
//
    VectorXs dx = qe - qs;
    double totalmass = 0;
    VectorXs cm(2);
    cm.setZero();
    VectorXs p(2);
    p.setZero();
    double angularp = 0;
    
    double I = 0;
    
    bool hasfixed = false;
    
    for(std::set<int>::iterator it = zone.m_verts.begin(); it != zone.m_verts.end(); ++it)
    {
        cm += scene.getM()[2* *it] * qs.segment<2>(2* *it);
        p += scene.getM()[2* *it] * dx.segment<2>(2* *it);
        totalmass += scene.getM()[2* *it];
        if(scene.isFixed(*it))
            hasfixed = true;
    }
    
    cm /= totalmass;
    p /= totalmass;
    
    for(std::set<int>::iterator it = zone.m_verts.begin(); it != zone.m_verts.end(); ++it)
    {
        VectorXs v = dx.segment<2>(2* *it) - p;
        VectorXs r = qs.segment<2>(2* *it) - cm;
        double L = r[0]*v[1] - r[1]*v[0];
        L *= scene.getM()[2* *it];
        angularp += L;
        
        I += scene.getM()[2* *it] * r.dot(r);
    }
    
    if(hasfixed || zone.m_halfplane)
    {
        for(std::set<int>::iterator it = zone.m_verts.begin(); it != zone.m_verts.end(); ++it)
        {
            qe.segment<2>(2* *it) = qs.segment<2>(2* *it);
            qdote.segment<2>(2* *it)*=0;
        }
        return;
    }
    
    double w = angularp/I;
    
    for(std::set<int>::iterator it = zone.m_verts.begin(); it != zone.m_verts.end(); ++it)
    {
        VectorXs r = qs.segment<2>(2* *it) - cm;
        VectorXs rperp = r;
        std::swap(rperp[0], rperp[1]);
        rperp[0]*=-1;
        qe.segment<2>(2* *it) = cm + p + cos(w)*r + sin(w)*rperp;
        qdote.segment<2>(2* *it) = (qe.segment<2>(2* *it) - qs.segment<2>(2* *it))/dt;
    }
}


// Performs iterative geometric collision response until collision-free end-of-time-step positions and velocities are found. See the assignment
// instructions for details.
// Inputs:
//   scene:   The simulation scene. Get masses, radii, etc. from here. Do *NOT* get any positions or velocities from here.
//   qs:      The start-of-time-step positions.
//   qe:      The predicted end-of-time-step positions.
//   qdote:   The predicted end-of-time-step velocities.
//   dt:      The time step size.
// Outputs:
//   qm:    The final, collision-free end-of-time-step positions. (qm in the assignment instructions.)
//   qdotm: Same as qm, but for velocities.
// Possibly useful functions: detectCollisions, performFailsafe. You may find it helpful to write other helper functions for manipulating (merging,
// growing, etc) impact zones.
void HybridCollisionHandler::applyGeometricCollisionHandling(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qm, VectorXs &qdotm)
{
    ImpactZones Z;
    ImpactZones Zprime;
    
//    //
//    // What you need to implement here: (same as writeup section 4.6)
//    //
//    // 1. Perform continuous-time collision detection using positions qs and qe.
//    // 2. Initialize qm = qe and qdotm = qdote.
//    // 3. Construct a list of disjoint impact zones Z from the detected collisions.
//    // 4. For each impact zone in Z, apply geometric collision response (by calling 
//    //      HybrdiCollisionHandler::performFailsafe, using positions qs and qm, and
//    //      modifying qm and qdotm for the vertices in those zones.
//    // 5. Perform continuous-time collision detection using positions qs and qm. 
//    // 6. Construct a new list of impact zones Z′ consisting of all impact zones in Z, 
//    //      plus one zone for each detected collision.
//    // 7. Merge the zones in Z' to get disjoint impact zones.
//    // 8. If Z and Z' are equal, the algorithm is done, and qm and qdotm are the new, 
//    //      collision-free end-of-time-step positions. Z and Z' are equal if they 
//    //      contain exactly the same impact zones; impact zones are the same if they 
//    //      contain the same particles and they both involve, or both don’t involve, 
//    //      a half-plane. If Z != Z', go to step 9.
//    // 9. Set Z=Z' and goto step4.
//    //
//    
//    // Your implementation here
//
    int iter=0;
    
    std::vector<CollisionInfo> collisions = detectCollisions(scene, qs, qe);
    qm = qe;
    qdotm = qdote;
    
    growImpactZones(scene, Z, collisions);
    
    while(true)
    {        
        iter++;
        
        // Body of algorithm loop goes here
        for(int i=0; i<(int)Z.size(); i++)
            performFailsafe(scene, qs, Z[i], dt, qm, qdotm);
        collisions = detectCollisions(scene, qs, qm);
        ImpactZones oldzones=Z;
        growImpactZones(scene, Z, collisions);
        if(zonesEqual(oldzones, Z))
            break;
    }    
}

